#!/bin/sh --
#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

#
# Startup wrapper for Update Tool GUI
#

# Resolve a symbolic link to the true file location
resolve_symlink () {
    file="$1"
    while [ -h "$file" ]; do
        ls=`ls -ld "$file"`
        link=`expr "$ls" : '^.*-> \(.*\)$' 2>/dev/null`
        if expr "$link" : '^/' 2> /dev/null >/dev/null; then
            file="$link"
        else
            file=`dirname "$1"`"/$link"
        fi
    done
    echo "$file"
}

# Take a relative path and make it absolute. Pwd -P will
# resolve any symlinks in the path
make_absolute () {
    save_pwd=`pwd`
    cd "$1";
    full_path=`pwd -P`
    cd "$save_pwd"
    echo "$full_path"
}


check_linux_64() {
    # Check to see if we are running on a 64 bit linux distro without
    # 32 bit compat libraries. This is just a heuristic, so it will only
    # catch obvious cases

    os_name=`uname -s`
    os_isa=`uname -m`

    if [ "$os_name" = "Linux" -a "$os_isa" = "x86_64" ]; then
        # Check for a couple landmark libraries
        # to determine if the 32bit compat packages have been installed.
        # A 32bit version of each library must exist, but we may have
        # to look in a couple locations for them.
        landmarks="libc.so.6 libz.so.1"
        # Directories to check for libraries
        libdirs="/lib /lib32 /usr/lib /usr/lib32"
        for f in $landmarks; do
            _32bit_compat="0"
            for d in $libdirs; do
                if [ ! -f $d/$f ]; then
                    continue
                fi
                # Check if 32 bit
                output=`objdump -f $d/$f | grep -i "elf32"`
                if [ -z "$output" ]; then
                    continue
                fi
                _32bit_compat="1"
                break
            done
            if [ "$_32bit_compat" = "0" ]; then
                # Darn. Couldn't find a 32 bit version of a landmark lib
                break;
            fi
        done

        if [ "$_32bit_compat" = "0" ]; then
            echo "---------------------------------------------------------------"
            echo "There was an error running"
            echo
            echo "$my_python/bin/python"
            echo
            echo "You are running on a 64 bit Linux distribution and the 32 bit Linux"
            echo "compatibility libraries do not appear to be installed. In order to use"
            echo "the Update Center tools you must install the 32 bit compatibility libraries."
            echo
            echo "On Ubuntu (and possibly other Debian based systems) please install the"
            echo "ia32-libs package. On RedHat 4 (and other RPM based systems), you may"
            echo "need to add multiple 'compat' runtime library packages. Please see the"
            echo "Update Center Release Notes for more information"
            echo "---------------------------------------------------------------"
        fi
    fi
}

# Since we always use the bundled python runtime, make sure user's
# environment does not mess us up (bug 119)
unset PYTHONSTARTUP
unset PYTHONHOME
unset PYTHONPATH

notifier=off
shutdown=off
swupdate=off
frommacapp=off

# Determine if we need to start the notifier or gui
for arg in "$@"
do
    if [ "$arg" = "--notifier" ] \
    || [ "$arg" = "-n" ]; then
        notifier=on
    elif [ "$arg" = "--shutdown" ]; then
        shutdown=on
    elif [ "$arg" = "--swupdate" ] \
    || [ "$arg" = "-u" ]; then
        swupdate=on
    elif [ "$arg" = "--macapp" ]; then
        frommacapp=on
    fi
done
if [ "$notifier" = "off" ] && [ "$swupdate" = "off" ]; then
    # Notifier and SW Update wants to quit by Ctrl+C but GUI doesn't
    trap "" INT
fi


# Find out where we are installed
cmd=`resolve_symlink "$0"`
my_home_relative=`/usr/bin/dirname "$cmd"`
my_home=`make_absolute "$my_home_relative"`

my_python=$my_home/../../pkg/python2.4-minimal
my_python_cmd=python

os_name=`uname -s`
if [ $os_name = "Darwin" ]; then

    macos_minor_ver=`sw_vers -productVersion | cut -d. -f 2`

    if [ "$frommacapp" = "off" ] && [ "$shutdown" = "off" ]; then
        # We are being called from the CLI on the Mac. In this case we can't
        # run python directly since in order for it to interact with the window
        # system it must be running in the context of a .app. So instead we
        # Open the UpdateTool app which in turn will call this script again
        # but with "--macapp". When that occurs we can safely run python to
        # start the GUI.
        #
        # Since we can't pass command line options directly via "open"
        # we pass them via an environment variable. The UpdateTool.app will
        # then pass those back to us when this script is called from within
        # UpdateTool.app. Got it!?
        __UC_ARGS="$@"; export __UC_ARGS

        # .app wrapper puts output here
        __UC_OUTPUT="/tmp/ucoutput-$$.log"; export __UC_OUTPUT

        # .app wrapper puts exit code here.
        __UC_STATUS="/tmp/ucstatus-$$.log"; export __UC_STATUS

        if [ "$notifier" = "on" ] ; then
            my_app="lib/UpdateToolNotifier.app"
        elif [ "$swupdate" = "on" ] ; then
            my_app="lib/SoftwareUpdate.app"
        else
            my_app="UpdateTool.app"
        fi

        # Also related to 687. For some reason using a full path with a
        # ".." in it tends to trigger the bug. So we cd there and launch
        # using a relative path
        cd "$my_home/.."

        if [ "$macos_minor_ver" = "4" ] || [ "$macos_minor_ver" = "3" ]; then
            # 10.4 does not support -W
            waitflag=""
            # Bug 687: force the Launch Service to re-register the app
            # by updating it's modification time. This is to work-around an
            # issue we've seen on 10.4 where somehow the LS ends up with a
            # bad registry entry. This is a hack until we figure out the
            # root cause of the bad entry.
            touch -m $my_app > /dev/null 2>&1
        else
            waitflag="-W"
        fi

        # WARNING: The open method does not return the exit code of the object 
        # it executes.
        open  $waitflag "$my_app"
        _status=$?

        # If there was output from the .app wrapper then print it
        # We sleep a second to give the wrapper time to write to the log
        sleep 2
        if [ -f "$__UC_OUTPUT" ]; then
            cat "$__UC_OUTPUT"
            rm "$__UC_OUTPUT"
        fi

        # If the __UC_STATUS is set then set our exit code to that value.
        if [ -f "$__UC_STATUS" ]; then
            _status=`cat "$__UC_STATUS"`
            rm "$__UC_STATUS"
        fi
        exit $_status
    fi

    if [ "$macos_minor_ver" = "4" ] || [ "$macos_minor_ver" = "3" ]; then
        if [ -x "$my_python/bin/Update Tool" ]; then
            # Bug 588: A hack on 10.4. If there is a python executable
            # named "Update Tool" then use it. This ensures our
            # Application menu says the right thing on 10.4
            my_python_cmd="Update Tool"
        fi
    fi

    # Set DYLD_LIBRARY_PATH so we can find libraries that python
    # modules depend on such as libcurl.
    PYTHONHOME=$my_python
    export PYTHONHOME
    DYLD_LIBRARY_PATH=$PYTHONHOME/lib
    export DYLD_LIBRARY_PATH
else
    # Hack to find bundled openssl libraries on Solaris
    unset LD_LIBRARY_PATH_32
    unset LD_LIBRARY_PATH_64
    LD_LIBRARY_PATH=$my_python/lib
    export LD_LIBRARY_PATH
    if [ $os_name = "AIX" ]; then
        # Set LIBPATH on AIX (bug UPDATECENTER2-2184)
        LIBPATH=$LD_LIBRARY_PATH
        export LIBPATH
    fi

    # Issue 1195
    # Disable GTK IIIM Switcher Menu on Solaris/Linux since we don't handle it
    GTK_IM_MODULE=gtk-im-context-simple
    export GTK_IM_MODULE
fi

# Restart loop.  If the notifier or GUI exists with 88 then restart it.
_restart=true
_status=0
while [ $_restart ]; do
    if [ "$notifier" = "on" ] ; then
        if [ $_status -eq 88 ] && [ "$frommacapp" = "off" ]; then
            "$my_python/bin/$my_python_cmd" "$my_home/../vendor-packages/updatetool/main.py" "$@" "--restarted" "--toolpath=$my_home/updatetool" &
        else
            "$my_python/bin/$my_python_cmd" "$my_home/../vendor-packages/updatetool/main.py" "$@" "--toolpath=$my_home/updatetool" &
        fi
    else
        "$my_python/bin/$my_python_cmd" "$my_home/../vendor-packages/updatetool/main.py" "$@" "--toolpath=$my_home/updatetool" &
    fi
    _pid=$!
    wait $_pid
    _status=$?

    # If we were started from an OS X app (frommacapp = true) then we defer
    # the restart to the Updatetool script contained within the
    # Updatetool.app.  This avoids one extra updatetool script remaining
    # after the restart.
    if [ $_status -eq 88 ] && [ "$frommacapp" = "off" ]; then
        # 88 means restart
        # We pause to avoid pegging the system in case we got here accidentally
        sleep 1
    elif [ $_status -ne 0 ]; then
        _restart=
        # Python exited with an error. Go check to see if this is because
        # We are running on 64 bit Linux.
        check_linux_64
    else
        _restart=
    fi
done


exit $_status
