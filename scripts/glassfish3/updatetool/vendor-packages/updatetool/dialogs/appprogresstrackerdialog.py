# -*- coding: utf-8 -*-
#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2009-2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

#
# generated by wxGlade 0.6.3

if False:    # Keep Pylint happy
    import gettext
    _ = gettext.gettext

import wx.lib.newevent
import time
import common.utils as utils
import common.task as task

class AppProgressTrackerDialog(wx.Dialog):

    _ = wx.GetTranslation

    UPDATE_INTERVAL = 0.5

    def __init__(self, *args, **kwds):
        self.task = kwds['task']
        del kwds['task']
        self.last_status_update_time = 0
        self._cache_progress_value = 0
        self._cache_progress_text = u""

        # begin wxGlade: AppProgressTrackerDialog.__init__
        kwds["style"] = wx.CAPTION
        wx.Dialog.__init__(self, *args, **kwds)
        self.progress_gauge = wx.Gauge(self, -1, 100, style=wx.GA_HORIZONTAL|wx.GA_SMOOTH)
        self.progress_label = wx.StaticText(self, -1, _("Processing..."))
        self.elapsed_time_label = wx.StaticText(self, -1, _("Elapsed time:"), style=wx.ALIGN_RIGHT)
        self.elapsed_time_value_label = wx.StaticText(self, -1, _("00:00"), style=wx.ALIGN_RIGHT)
        #self.remaining_time_label = wx.StaticText(self, -1, _("Remaining time:"), style=wx.ALIGN_RIGHT)
        #self.remaining_time_value_label = wx.StaticText(self, -1, _("00:00"), style=wx.ALIGN_RIGHT)
        self.coll_pane = wx.Panel(self, -1)
        self.cancel_button = wx.Button(self, -1, _("&Cancel"))

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnCancel, self.cancel_button)
        # end wxGlade
        self.Centre()
        self.cancel_button.Enable(self.task.is_interruptable)
        timer_id = wx.NewId()
        self.timer = wx.Timer(self, timer_id)
        self.timer.Start(100)  # x100 milliseconds
        wx.EVT_TIMER(self, timer_id, self.OnTimerEvent)  # call the on_timer function


    def __set_properties(self):
        # begin wxGlade: AppProgressTrackerDialog.__set_properties
        self.SetTitle(_("Progress"))
        self.progress_gauge.SetMinSize((500,-1))
        self.progress_gauge.SetToolTipString(_("Progress of current execution"))
        #self.remaining_time_label.Hide()
        #self.remaining_time_value_label.Hide()
        self.coll_pane.Hide()
        self.cancel_button.SetToolTipString(_("Cancel this execution"))
        self.cancel_button.Enable(False)
        # end wxGlade
        # tasks tell us how they are doing
        self.Bind(task.EVT_TASK_PROGRESS_START, self.OnTaskProgressStart)
        self.Bind(task.EVT_TASK_PROGRESS, self.OnTaskProgress)
        self.Bind(task.EVT_TASK_FINISHED, self.OnTaskFinished)
        self.Bind(task.EVT_CANCEL_ABILITY_CHANGE, self.OnCancelEnable)
        self.Bind(task.EVT_TASK_DURATION_CHANGED, self.OnTaskDurationChanged)
        self.Bind(task.EVT_TASK_LOG, self.OnTaskLog)


    def __do_layout(self):
        # begin wxGlade: AppProgressTrackerDialog.__do_layout
        grid_sizer_1 = wx.FlexGridSizer(6, 1, 5, 0)
        grid_sizer_2 = wx.FlexGridSizer(1, 2, 0, 5)
        grid_sizer_3 = wx.FlexGridSizer(1, 2, 5, 5)
        grid_sizer_1.Add((20, 10), 0, 0, 0)
        grid_sizer_1.Add(self.progress_gauge, 0, wx.ALL|wx.EXPAND, 12)
        grid_sizer_2.Add(self.progress_label, 1, wx.LEFT|wx.RIGHT|wx.BOTTOM|wx.EXPAND, 12)
        grid_sizer_3.Add(self.elapsed_time_label, 0, wx.ALL|wx.ALIGN_RIGHT, 5)
        grid_sizer_3.Add(self.elapsed_time_value_label, 0, wx.ALL, 5)
        #grid_sizer_3.Add(self.remaining_time_label, 0, wx.ALL, 5)
        #grid_sizer_3.Add(self.remaining_time_value_label, 0, wx.ALL, 5)
        grid_sizer_3.AddGrowableCol(0)
        grid_sizer_2.Add(grid_sizer_3, 1, wx.RIGHT|wx.BOTTOM|wx.EXPAND, 12)
        grid_sizer_2.AddGrowableCol(0)
        grid_sizer_1.Add(grid_sizer_2, 1, wx.EXPAND, 0)
        grid_sizer_1.Add(self.coll_pane, 1, wx.ALL|wx.EXPAND, 5)
        grid_sizer_1.Add(self.cancel_button, 0, wx.RIGHT|wx.BOTTOM|wx.ALIGN_RIGHT, 10)
        self.SetSizer(grid_sizer_1)
        grid_sizer_1.Fit(self)
        grid_sizer_1.AddGrowableRow(2)
        grid_sizer_1.AddGrowableRow(3)
        grid_sizer_1.AddGrowableCol(0)
        self.Layout()
        # end wxGlade
        self._make_cp_content()


    def _make_cp_content(self):
        new_coll_pane = wx.CollapsiblePane(self, -1, label="Show details", style=wx.CP_DEFAULT_STYLE|wx.CP_NO_TLW_RESIZE)
        old_sizer = self.GetSizer()
        old_sizer.Replace(self.coll_pane, new_coll_pane)
        old_coll_pane, self.coll_pane = self.coll_pane, new_coll_pane
        old_coll_pane.Destroy()
        del old_coll_pane
        content_pane = self.coll_pane.GetPane()
        self.coll_pane.SetSize((-1, 100))
        self.coll_pane.progress_log = wx.TextCtrl(content_pane, -1, "", style=wx.TE_READONLY|wx.TE_NOHIDESEL|wx.TE_MULTILINE|wx.TE_DONTWRAP)
        self.coll_pane.progress_log.SetMinSize((-1, 100))
        sizer = wx.BoxSizer()
        sizer.Add(self.coll_pane.progress_log, 1, wx.EXPAND|wx.ALL, 5)
        content_pane.SetSizer(sizer)
        self.Bind(wx.EVT_COLLAPSIBLEPANE_CHANGED, self.OnPaneChanged, self.coll_pane)
        # XXX : Hide it for now till we have more useful progress logs
        self.coll_pane.Hide()


    def OnPaneChanged(self, event=None):
        self.GetSizer().Fit(self)

        if self.coll_pane.IsExpanded():
            self.coll_pane.SetLabel("Hide details")
        else:
            self.coll_pane.SetLabel("Show details")


    def OnCancel(self, event): # wxGlade: AppProgressTrackerDialog.<event_handler>
        if self.task.is_running():
            self.task.interrupt()
        event.Skip()


    def OnCancelEnable(self, event):
        self.cancel_button.Enable(event.enable)
        wx.YieldIfNeeded()


    def OnTaskProgressStart(self, event):
        #print >> sys.stderr, "Setting duration", event.duration
        self.progress_gauge.SetRange(event.duration)
        self.last_status_update_time = time.time()
        self.GetSizer().Fit(self)


    def OnTaskDurationChanged(self, event):
        self.OnTaskProgressStart(event)


    def OnTaskProgress(self, event):
        self._cache_progress_value = event.count
        if time.time() - self.last_status_update_time > AppProgressTrackerDialog.UPDATE_INTERVAL:
            self.progress_gauge.SetValue(self._cache_progress_value)
            #self.remaining_time_value_label.SetLabel(self.task.get_remaining_time())
            self.elapsed_time_value_label.SetLabel(self.task.get_elapsed_time())
            txt = utils.to_unicode(self.task.__str__())
            self.coll_pane.progress_log.AppendText(txt)
            self.coll_pane.progress_log.AppendText("\n")

            refit = False
            if txt != self._cache_progress_text:
                self.progress_label.SetLabel(txt)
                refit = True
                self._cache_progress_text = txt
            self.last_status_update_time = time.time()
            if refit:
                self.GetSizer().Fit(self)


    def OnTimerEvent(self, dummy_event):
        if time.time() - self.last_status_update_time > AppProgressTrackerDialog.UPDATE_INTERVAL:
            if self.progress_gauge.GetValue() != self._cache_progress_value:
                self.progress_gauge.SetValue(self._cache_progress_value)
            #self.remaining_time_value_label.SetLabel(self.task.get_remaining_time())
            self.elapsed_time_value_label.SetLabel(self.task.get_elapsed_time())
            refit = False
            txt = utils.to_unicode(self.task.__str__())
            if txt != self._cache_progress_text:
                self.progress_label.SetLabel(txt)
                self._cache_progress_text = txt
                refit = True
            self.last_status_update_time = time.time()
            if refit:
                self.GetSizer().Fit(self)


    def OnTaskFinished(self, dummy_event):
        self._cache_progress_value = 0
        self.progress_gauge.SetValue(0)
        #self.progress_label.SetLabel("Finished")
        self.timer.Stop()
        self.Hide()


    def OnTaskLog(self, event):
        pass

#
# end of class AppProgressTrackerDialog
